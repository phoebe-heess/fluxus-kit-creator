<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Fluxus FC — Kit Creator</title>
  <style>
    :root{ --bg:#000000; --panel:#1a1a1a; --muted:#666666; --accent:#ffffff; --text:#ffffff; --danger:#ff0000; }
    html,body{height:100%}
    body{margin:0;background:#000000;color:var(--text);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Inter,"Helvetica Neue",Arial,Noto Sans,"Apple Color Emoji","Segoe UI Emoji"}
    .app{position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr}
    header{display:flex;align-items:center;gap:.75rem;padding:.75rem 1rem;border-bottom:1px solid #333333;background:linear-gradient(180deg,rgba(255,255,255,.1),rgba(255,255,255,0));backdrop-filter:saturate(140%) blur(6px)}
    header img{height:28px;width:auto}
    header h1{font-size:16px;margin:0;font-weight:600;letter-spacing:.3px}
    header .grow{flex:1}
    header .btn{background:#1a1a1a;border:1px solid #333333;color:var(--text);padding:.5rem .75rem;border-radius:6px;cursor:pointer;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,"Helvetica Neue",Arial,Noto Sans}
    header .btn[disabled]{opacity:.6;cursor:not-allowed}

    .layout{display:grid;grid-template-columns:minmax(0,1fr);grid-template-rows:1fr auto}
    @media (min-width:900px){.layout{grid-template-columns:1fr 340px;grid-template-rows:1fr}}

    #stage{position:relative;background:transparent}
    canvas{display:block;width:100%;height:100%}

    aside{border-left:1px solid #333333;background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(255,255,255,0))}
    .panel{padding:12px 12px 80px;height:100%;overflow:auto}
    .section{margin:12px 0;padding:12px;background:var(--panel);border:1px solid #333333;border-radius:8px}
    .section h3{margin:0 0 .5rem 0;font-size:13px;letter-spacing:.3px;color:#cccccc;text-transform:uppercase;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,"Helvetica Neue",Arial,Noto Sans}
    .row{display:flex;align-items:center;gap:.5rem;margin:.5rem 0}
    .row input[type="range"]{flex:1}
    .row input[type="file"]{flex:1}
    .layers{display:flex;flex-direction:column;gap:.5rem}
    .layer{display:flex;gap:.5rem;align-items:center;background:#1a1a1a;border:1px solid #333333;border-radius:6px;padding:.5rem}
    .layer button{border:1px solid #333333;background:#1a1a1a;color:var(--text);padding:.4rem .5rem;border-radius:4px;cursor:pointer;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,"Helvetica Neue",Arial,Noto Sans}
    .layer .name{flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:#cccccc}
    .small{font-size:12px;color:#999999;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,"Helvetica Neue",Arial,Noto Sans}
    .footer{position:fixed;right:12px;bottom:12px;display:flex;gap:.5rem}
    .fab{background:var(--accent);color:#000000;border:none;border-radius:6px;padding:.8rem 1rem;font-weight:600;cursor:pointer;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,"Helvetica Neue",Arial,Noto Sans}
    .ghost{background:transparent;color:var(--text);border:1px solid #333333;border-radius:6px;padding:.8rem 1rem;font-weight:600;cursor:pointer;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,"Helvetica Neue",Arial,Noto Sans}

    .hint{position:absolute;left:12px;bottom:12px;padding:.45rem .6rem;background:#1a1a1a;border:1px solid #333333;border-radius:6px;color:#cccccc;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,"Helvetica Neue",Arial,Noto Sans}

    /* collapsible section for mobile */
    .collapsible{max-height:0;overflow:hidden;transition:max-height .25s ease}
    .collapsible.open{max-height:800px}
  </style>
</head>
<body>
<div class="app">
  <header>
    <img src="./fluxus-fc-logo.png" alt="Fluxus FC" onerror="this.style.display='none'" />
    <h1>Fluxus FC — Kit Creator</h1>
    <div class="grow"></div>
    <button class="btn" id="artworksBtn" title="Shows your NFTs">Login</button>
    <button class="btn" id="resetBtn" title="Reset all">Reset</button>
  </header>

  <div class="layout">
    <div id="stage"></div>

    <aside>
      <div class="panel">
        <div class="section">
          <h3>Tools</h3>
          <div class="row">
            <button id="toggleGrid" class="btn">Grid</button>
            <button id="connectWallet" class="btn">Connect Wallet</button>
            <button id="mintBtn" class="btn" title="Coming soon" disabled>Mint</button>
          </div>
          <p class="small">Grid helps symmetry. Wallet shows your NFTs to drag onto the shirt.</p>
        </div>

        <div class="section">
          <h3>Upload image</h3>
          <div class="row">
            <input id="fileInput" type="file" accept="image/*" />
            <button id="addDecalBtn">Add</button>
          </div>
          <p class="small">Tip: tap shirt to place; pinch to scale; two-finger rotate. Use buttons on a selected image to resize/flip/rotate.</p>
        </div>

        <div class="section" id="nftSection">
          <h3 style="display:flex;align-items:center;justify-content:space-between">NFTs in wallet <span id="walletStatus" class="small" style="font-weight:500;">Not connected</span></h3>
          <div class="collapsible" id="nftCollapse">
            <div id="nftGrid" style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:8px"></div>
            <p class="small" style="margin-top:8px">Drag a thumbnail onto the shirt to place it.</p>
          </div>
        </div>


      </div>
    </aside>
  </div>

</div>

<div class="hint" id="hint">Tap shirt to place, drag to move, scroll/pinch to scale, hold Alt to rotate.</div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
      
      // Make them globally available
      window.THREE = THREE;
      window.OrbitControls = OrbitControls;
      window.GLTFLoader = GLTFLoader;
      
      console.log('Three.js modules loaded successfully');
      console.log('THREE:', typeof THREE);
      console.log('OrbitControls:', typeof OrbitControls);
      console.log('GLTFLoader:', typeof GLTFLoader);
    </script>
<script>
  // Wait for modules to load
  function waitForModules() {
    if (typeof window.THREE !== 'undefined' && 
        typeof window.OrbitControls !== 'undefined' && 
        typeof window.GLTFLoader !== 'undefined') {
      console.log('All modules loaded successfully!');
      console.log('THREE:', typeof window.THREE);
      console.log('OrbitControls:', typeof window.OrbitControls);
      console.log('GLTFLoader:', typeof window.GLTFLoader);
      
      // Initialize the app
      initApp();
    } else {
      console.log('Waiting for modules...');
      setTimeout(waitForModules, 100);
    }
  }
  
  // Start waiting when page loads
  window.addEventListener('load', function() {
    setTimeout(waitForModules, 100);
  });
  
  function initApp() {

  // ==== OBJKT login mirror & Beacon fallback ====
  const isEmbedded = (function(){ try{ return window.top !== window; }catch(e){ return true; } })();
  const fromObjkt = /objkt\.com/i.test(document.referrer||'') || /objkt\.com/i.test(location.ancestorOrigins?.[0]||'');
  let parentWallet = null; let walletAddress = null;

  function askParentForWallet(timeoutMs=1400){
    return new Promise((resolve)=>{
      let settled=false; const t = setTimeout(()=>{ if(!settled){ settled=true; resolve(null);} }, timeoutMs);
      function onMsg(ev){
        if(ev?.data && ev.data.type === 'OBJKT_WALLET' && ev.data.address){
          settled=true; clearTimeout(t); window.removeEventListener('message', onMsg);
          resolve(ev.data.address);
        }
      }
      window.addEventListener('message', onMsg);
      try{ window.parent.postMessage({ type:'FLUXUS_REQUEST_WALLET' }, '*'); }catch(err){}
    });
  }

  async function tryObjktSession(){
    if(!(isEmbedded||fromObjkt)) return null;
    const addr = await askParentForWallet();
    if(addr){ parentWallet = addr; const artBtn=document.getElementById('artworksBtn'); if(artBtn){ artBtn.textContent='Artworks'; artBtn.disabled=false; artBtn.style.opacity='1'; } const walletBtn=document.getElementById('connectWallet'); if(walletBtn) walletBtn.style.display='none'; }
    return parentWallet;
  }

  // ==== Scene setup ====
  const stage = document.getElementById('stage');
  const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, preserveDrawingBuffer:true });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2)); stage.appendChild(renderer.domElement);
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100); camera.position.set(0.2, 1.5, 3.2);
  let controls = null;
  if (typeof window.OrbitControls !== 'undefined') {
    controls = new window.OrbitControls(camera, renderer.domElement); 
    controls.enableDamping = true; 
    controls.minDistance = 1.6; 
    controls.maxDistance = 4.5; 
    controls.maxPolarAngle = Math.PI*0.49;
    console.log('OrbitControls initialized successfully');
  } else {
    console.warn('Using basic camera controls - OrbitControls not available');
  }
  const hemi = new THREE.HemisphereLight(0xffffff, 0x22334a, 0.6); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(2,4,2); dir.castShadow=false; scene.add(dir);
  const baseGroup = new THREE.Group(); scene.add(baseGroup);

  const g = new THREE.PlaneGeometry(20,20); const m = new THREE.MeshBasicMaterial({color:0x0b0e13}); const ground = new THREE.Mesh(g,m); ground.rotation.x=-Math.PI/2; ground.position.y=-1.1; ground.renderOrder=-1; ground.visible=false; scene.add(ground);
  
  // Create grid texture material
  function createGridTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    const ctx = canvas.getContext('2d');
    
    // White background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, 256, 256);
    
    // Light blue grid lines
    ctx.strokeStyle = '#66ccff';
    ctx.lineWidth = 1.5;
    
    // Draw vertical lines (more lines for smaller grid)
    for (let i = 0; i <= 16; i++) {
      const x = (i / 16) * 256;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, 256);
      ctx.stroke();
    }
    
    // Draw horizontal lines (more lines for smaller grid)
    for (let i = 0; i <= 16; i++) {
      const y = (i / 16) * 256;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(256, y);
      ctx.stroke();
    }
    
    const texture = new THREE.CanvasTexture(canvas);
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(3, 3); // More repeats for smaller grid pattern
    
    return texture;
  }
  
  // Create materials
  const plainShirtMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
  const gridShirtMat = new THREE.MeshLambertMaterial({ 
    color: 0xffffff,
    map: createGridTexture()
  });
  
  let isGridOn = false;

  function resize(){ const w = stage.clientWidth || window.innerWidth; const h = stage.clientHeight || (window.innerHeight - 56); renderer.setSize(w,h,false); camera.aspect=w/h; camera.updateProjectionMatrix(); }
  new ResizeObserver(resize).observe(stage); window.addEventListener('orientationchange',()=>setTimeout(resize,200));

  // Shirt
  let shirtMesh=null; let shirtCenter=new THREE.Vector3(); let shirtHeight=2;

  async function loadShirt(){
    if (typeof window.GLTFLoader !== 'undefined') {
      const loader = new window.GLTFLoader();
      try{
        console.log('Loading 3D model...');
        const glb = await loader.loadAsync('./objkt-3d-viewport.glb');
        console.log('3D model loaded successfully:', glb);
        const root = glb.scene;
        // Store reference to the entire shirt group, not just one mesh
        shirtMesh = root;
        
        // First, let's analyze all meshes to understand the structure
        const meshInfo = [];
        root.traverse(o=>{ 
          if(o.isMesh){ 
            const box = new THREE.Box3().setFromObject(o);
            const center = new THREE.Vector3();
            box.getCenter(center);
            const size = new THREE.Vector3();
            box.getSize(size);
            
            meshInfo.push({
              name: o.name || 'unnamed',
              center: center.clone(),
              size: size.clone(),
              mesh: o
            });
          }
        });
        
        // Sort meshes by Y position to identify collar (highest) and inside parts
        meshInfo.sort((a, b) => b.center.y - a.center.y);
        
        console.log('Mesh analysis:');
        meshInfo.forEach((info, index) => {
          console.log(`${index}: ${info.name} - Y: ${info.center.y.toFixed(2)}, Size: ${info.size.x.toFixed(2)}x${info.size.y.toFixed(2)}x${info.size.z.toFixed(2)}`);
        });
        
        // Apply materials - exclude top 2-3 meshes (likely collar) and bottom meshes (likely inside)
        const excludeTop = 2; // Exclude top 2 meshes (collar area)
        const excludeBottom = 2; // Exclude bottom 2 meshes (inside area)
        
        meshInfo.forEach((info, index) => {
          const shouldExclude = index < excludeTop || index >= meshInfo.length - excludeBottom;
          
          info.mesh.material = shouldExclude ? plainShirtMat : plainShirtMat; // Start with plain, will be toggled
          info.mesh.castShadow=false; 
          info.mesh.receiveShadow=false; 
          info.mesh.geometry.computeBoundingSphere();
          
          console.log(`Applied material to mesh: ${info.name} ${shouldExclude ? '(EXCLUDED from grid)' : '(will get grid)'}`);
        });
        baseGroup.add(root);
        const box = new THREE.Box3().setFromObject(root); box.getCenter(shirtCenter); const size = new THREE.Vector3(); box.getSize(size); shirtHeight = size.y || 2;
        if (controls) controls.target.copy(shirtCenter);
        console.log('Shirt mesh added to scene');
      }catch(err){
        console.error('Failed to load 3D model:', err);
        createFallbackShirt();
      }
    } else {
      console.log('GLTFLoader not available, using sphere fallback');
      createFallbackShirt();
    }
    resize();
  }
  
  function createFallbackShirt() {
    const geom = new THREE.SphereGeometry(1,64,64); 
    shirtMesh = new THREE.Mesh(geom, plainShirtMat); 
    baseGroup.add(shirtMesh); 
    if (controls) controls.target.set(0,0,0);
    console.log('Using sphere fallback for shirt');
  }

  // Decals (sprites over surface)
  const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2();
  const decals = [];
  const controlRingGeom = new THREE.RingGeometry(0.36, 0.38, 48);
  const controlRingMat = new THREE.MeshBasicMaterial({ color: 0x66ccff, transparent:true, opacity:0.5, depthTest:false });
  const controlRing = new THREE.Mesh(controlRingGeom, controlRingMat); controlRing.visible=false; controlRing.renderOrder=3; scene.add(controlRing);

  function makeDecal(tex){
    tex.colorSpace = THREE.SRGBColorSpace; tex.anisotropy = 2; tex.flipY = false;
    const mat = new THREE.SpriteMaterial({ map: tex, opacity: 1, depthTest: true, depthWrite: false, transparent: true });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(0.6, 0.6 * (tex.image.height/tex.image.width), 1);
    sprite.position.copy(shirtCenter);
    sprite.renderOrder = 2; // above grid & shirt
    baseGroup.add(sprite);
    decals.push({ mesh: sprite, texture: tex, name: (tex.image?.name || 'decal') });
    selectLayer(decals.length-1);
  }

  function placeAt(x,y){
    if(!shirtMesh) return; mouse.x=(x/renderer.domElement.clientWidth)*2-1; mouse.y=-(y/renderer.domElement.clientHeight)*2+1; raycaster.setFromCamera(mouse,camera);
    const hit = raycaster.intersectObject(shirtMesh,true)[0];
    if(hit){
      // geometric collar avoidance
      const horizDist = Math.hypot(hit.point.x - shirtCenter.x, hit.point.z - shirtCenter.z);
      const topY = shirtCenter.y + 0.45 * shirtHeight; // neckline region
      const nearNeck = (hit.point.y > topY) && (horizDist < 0.22 * shirtHeight);
      let picked = hit;
      if(nearNeck || (picked.object && /collar/i.test(picked.object.name||''))){
        const hits = raycaster.intersectObject(shirtMesh,true);
        picked = hits.find(h=>{ const hd=Math.hypot(h.point.x-shirtCenter.x,h.point.z-shirtCenter.z); const nn=(h.point.y>topY)&&(hd<0.22*shirtHeight); return !(nn || (/collar/i.test(h.object.name||''))); }) || hit;
      }
      const a = active(); a?.mesh.position.copy(picked.point.addScaledVector(picked.face.normal, 0.01)); controlRing.position.copy(a?.mesh.position||shirtCenter);
    }
  }

  function active(){ return decals[activeIndex]; }
  let activeIndex=-1; function selectLayer(i){ activeIndex=i; const a=active(); if(a){ controlRing.visible=true; controlRing.position.copy(a.mesh.position); controlRing.scale.setScalar(Math.abs(a.mesh.scale.x)*1.2);} else { controlRing.visible=false; } }


  // Pointer/touch controls
  let dragging=false; let lastDist=0; let lastAngle=0; 
  renderer.domElement.addEventListener('pointerdown', (e)=>{ dragging=true; placeAt(e.offsetX,e.offsetY); });
  renderer.domElement.addEventListener('pointermove', (e)=>{ if(dragging){ placeAt(e.offsetX,e.offsetY); const a=active(); if(a){ controlRing.position.copy(a.mesh.position); controlRing.scale.setScalar(Math.abs(a.mesh.scale.x)*1.2);} } });
  renderer.domElement.addEventListener('pointerup', ()=> dragging=false);
  renderer.domElement.addEventListener('wheel', (e)=>{ const a=active(); if(!a) return; const s=a.mesh.scale.x * (e.deltaY<0 ? 1.05 : 0.95); a.mesh.scale.setScalar(Math.max(0.05, Math.min(3, s))); });

  renderer.domElement.addEventListener('touchmove', (e)=>{
    if(e.touches.length===2){ e.preventDefault(); const a=active(); if(!a) return; const [t0,t1]=[e.touches[0], e.touches[1]]; const dx=t0.clientX-t1.clientX, dy=t0.clientY-t1.clientY; const dist=Math.hypot(dx,dy); const angle=Math.atan2(dy,dx); if(lastDist){ const scale=dist/lastDist; const s=a.mesh.scale.x*scale; a.mesh.scale.setScalar(Math.max(0.05, Math.min(3,s))); } if(lastAngle){ const da=angle-lastAngle; a.mesh.material.rotation += da; } lastDist=dist; lastAngle=angle; }
  }, {passive:false});
  renderer.domElement.addEventListener('touchend', ()=>{ lastDist=0; lastAngle=0; });

  // UI
  document.getElementById('resetBtn').onclick = ()=>{ decals.forEach(d=>baseGroup.remove(d.mesh)); decals.length=0; controlRing.visible=false; };
  document.getElementById('toggleGrid').onclick = ()=>{ 
    if (shirtMesh) {
      isGridOn = !isGridOn;
      
      // Apply material to all meshes in the shirt group using position-based exclusion
      const meshInfo = [];
      shirtMesh.traverse((child) => {
        if (child.isMesh) {
          const box = new THREE.Box3().setFromObject(child);
          const center = new THREE.Vector3();
          box.getCenter(center);
          
          meshInfo.push({
            name: child.name || 'unnamed',
            center: center.clone(),
            mesh: child
          });
        }
      });
      
      // Sort by Y position and exclude top/bottom meshes
      meshInfo.sort((a, b) => b.center.y - a.center.y);
      const excludeTop = 2; // Exclude top 2 meshes (collar area)
      const excludeBottom = 2; // Exclude bottom 2 meshes (inside area)
      
      meshInfo.forEach((info, index) => {
        const shouldExclude = index < excludeTop || index >= meshInfo.length - excludeBottom;
        info.mesh.material = shouldExclude ? plainShirtMat : (isGridOn ? gridShirtMat : plainShirtMat);
      });
      
      document.getElementById('toggleGrid').textContent = isGridOn ? 'Grid ON' : 'Grid';
      console.log('Grid toggled:', isGridOn ? 'ON' : 'OFF');
    }
  };

  const fileInput = document.getElementById('fileInput');
  document.getElementById('addDecalBtn').onclick = async ()=>{ const f=fileInput.files?.[0]; if(!f) return alert('Pick an image first'); const url=URL.createObjectURL(f); const img=new Image(); img.crossOrigin='anonymous'; img.name=f.name; await new Promise(r=>{ img.onload=r; img.src=url; }); const tex=new THREE.Texture(img); tex.needsUpdate=true; tex.image.name=f.name; makeDecal(tex); };


  // NFT fetch helpers (TZKT)
  const walletStatus = document.getElementById('walletStatus');
  const nftGrid = document.getElementById('nftGrid');
  const nftCollapse = document.getElementById('nftCollapse');
  const nftSection = document.getElementById('nftSection');

  function ipfsToHttp(uri){ if(!uri) return null; return uri.replace(/^ipfs:\/\//,'https://ipfs.io/ipfs/').replace(/^ipfs\/[\/]/,'https://ipfs.io/ipfs/'); }

  async function fetchNFTs(address){
    const url = `https://api.tzkt.io/v1/tokens/balances?account=${address}&token.standard=fa2&balance.ne=0&limit=250&select=token.metadata`;
    const res = await fetch(url); const data = await res.json(); const pics=[];
    for(const m of data){ const a=m?.artifactUri||m?.displayUri||m?.thumbnailUri; if(a){ pics.push({ src: ipfsToHttp(a), name: m?.name||'NFT' }); } }
    return pics.slice(0,60);
  }

  async function openArtworks(address){
    if(nftCollapse && !nftCollapse.classList.contains('open')){ nftCollapse.classList.add('open'); }
    if(nftSection){ nftSection.scrollIntoView({ behavior:'smooth', block:'start' }); }
    walletStatus.textContent = address || walletStatus.textContent;
    if(nftGrid.dataset.loadedFor === address) return;
    nftGrid.innerHTML = '<div class="small">Loading artworks…</div>';
    const pics = await fetchNFTs(address);
    nftGrid.innerHTML=''; pics.forEach(p=>{ const img=document.createElement('img'); img.src=p.src; img.alt=p.name; img.draggable=true; img.style.width='100%'; img.style.borderRadius='8px'; img.style.background='#0b1320'; img.style.objectFit='cover'; img.title='Drag onto shirt'; img.addEventListener('dragstart',(ev)=>{ ev.dataTransfer.setData('text/uri-list', p.src); }); nftGrid.appendChild(img); });
    nftGrid.dataset.loadedFor = address;
  }

  // Beacon fallback connect
  document.getElementById('connectWallet').onclick = async ()=>{
    walletStatus.textContent = 'Connecting…';
    try{
      const mod = await import('https://unpkg.com/@airgap/beacon-sdk@4.0.9/dist/walletbeacon.min.js');
      const DAppClient = mod.DAppClient || (mod?.beacon?.DAppClient);
      const bc = new DAppClient({ name: 'Fluxus FC' });
      const perms = await bc.requestPermissions({ network: { type: 'mainnet' } });
      walletAddress = perms.address; walletStatus.textContent = walletAddress;
      await openArtworks(walletAddress);
    }catch(err){ console.warn('Wallet connect failed or blocked', err); walletStatus.textContent = 'Could not connect'; }
  };

  // Drag-drop from thumbnails or links
  renderer.domElement.addEventListener('dragover', (e)=>{ e.preventDefault(); });
  renderer.domElement.addEventListener('drop', async (e)=>{ e.preventDefault(); const url=e.dataTransfer.getData('text/uri-list'); if(!url) return; const img=new Image(); img.crossOrigin='anonymous'; await new Promise(r=>{ img.onload=r; img.src=url; }); const tex=new THREE.Texture(img); tex.needsUpdate=true; tex.image.name=url.split('/').pop(); makeDecal(tex); });

  // Artworks button logic
  const artBtn = document.getElementById('artworksBtn');
  if(artBtn){ artBtn.onclick = async ()=>{ if(parentWallet){ walletAddress = parentWallet; await openArtworks(walletAddress); return; } try{ window.parent.postMessage({ type:'FLUXUS_OPEN_LOGIN' }, '*'); }catch(e){} const cb=document.getElementById('connectWallet'); if(cb) cb.click(); }; }

    // Boot
    function tick(){ 
      if (controls) controls.update(); 
      renderer.render(scene,camera); 
      requestAnimationFrame(tick); 
    }
    resize(); 
    console.log('Starting app...');
    console.log('Scene children:', scene.children.length);
    loadShirt().then(() => {
      console.log('Shirt loading completed');
      console.log('Scene children after load:', scene.children.length);
      console.log('BaseGroup children:', baseGroup.children.length);
      console.log('ShirtMesh:', shirtMesh);
    });
    tryObjktSession().then((addr)=>{ if(addr){ walletAddress = addr; walletStatus.textContent = walletAddress; /* waiting for Artworks click to fetch */ } });
    tick();
  }
</script>
</body>
</html>
